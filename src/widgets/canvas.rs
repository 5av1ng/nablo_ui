//! A canvas widget for displaying images and graphics.

use crate::{layout::{Layout, LayoutId}, prelude::{InputState, Painter, Rect, Vec2}};

use super::{Signal, SignalGenerator, Widget};

/// A canvas widget for displaying images and graphics.
pub struct Canvas<S: Signal> {
	/// The inner properties of the canvas.
	pub inner: CanvasInner,
	/// The signals generated by the canvas.
	pub signals: SignalGenerator<S, CanvasInner>,
}

/// The inner properties of a canvas widget.
pub struct CanvasInner {
	/// The size of the canvas.
	pub size: Vec2,
	/// The painter used to draw on the canvas.
	pub draw: Box<dyn Fn(&mut Painter)>,
	/// if the canvas should be refreshed every frame.
	pub refresh: bool,
}

impl<S: Signal> Canvas<S> {
	/// Creates a new canvas widget.
	pub fn new<T: Fn(&mut Painter) + 'static>(size: Vec2, draw: T, refresh: bool) -> Self {
		Canvas {
			inner: CanvasInner {
				size,
				draw: Box::new(draw),
				refresh,
			},
			signals: SignalGenerator::default(),
		}
	}
}

impl<S: Signal> Widget for Canvas<S> {
	type Signal = S;
	
	fn draw(&mut self, painter: &mut Painter, _: Vec2) {
		(self.inner.draw)(painter);
	}

	fn handle_event(&mut self, input_state: &mut InputState<Self::Signal>, id: LayoutId, area: Rect, _: Vec2) -> bool {
		self.signals.generate_signals(&mut self.inner, input_state, id, area, false, false);
		self.inner.refresh
	}

	fn size(&self, _: LayoutId, _: &Painter, _: &Layout<Self::Signal>) -> Vec2 {
		self.inner.size
	}
}