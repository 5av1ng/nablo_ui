//! A canvas widget for displaying images and graphics.

use crate::{layout::{Layout, LayoutId}, prelude::{InputState, Painter, Rect, Vec2}, App};

use super::{EventHandleStrategy, Signal, SignalGenerator, Widget};

/// A canvas widget for displaying images and graphics.
pub struct Canvas<S: Signal, A: App<Signal = S>> {
	/// The inner properties of the canvas.
	pub inner: CanvasInner,
	/// The signals generated by the canvas.
	pub signals: SignalGenerator<S, CanvasInner, A>,
}

/// The inner properties of a canvas widget.
pub struct CanvasInner {
	/// The size of the canvas.
	pub size: Vec2,
	/// The painter used to draw on the canvas.
	pub draw: Box<dyn Fn(&mut Painter)>,
	/// if the canvas should be refreshed every frame.
	pub refresh: bool,
	/// The event handling strategy of the canvas.
	pub event_handle_strategy: EventHandleStrategy,
}

impl<S: Signal, A: App<Signal = S>> Canvas<S, A> {
	/// Creates a new canvas widget.
	pub fn new<T: Fn(&mut Painter) + 'static>(size: Vec2, draw: T, refresh: bool) -> Self {
		Canvas {
			inner: CanvasInner {
				size,
				draw: Box::new(draw),
				refresh,
				event_handle_strategy: EventHandleStrategy::OnHover,
			},
			signals: SignalGenerator::default(),
		}
	}
}

impl<S: Signal, A: App<Signal = S>> Widget for Canvas<S, A> {
	type Signal = S;
	type Application = A;
	
	fn draw(&mut self, painter: &mut Painter, _: Vec2) {
		(self.inner.draw)(painter);
	}

	fn handle_event(&mut self, app: &mut A, input_state: &mut InputState<Self::Signal>, id: LayoutId, area: Rect, _: Vec2) -> bool {
		self.signals.generate_signals(
			app,
			&mut self.inner, 
			input_state, 
			id, 
			area, 
			false, 
			false
		);
		self.inner.refresh
	}

	fn size(&self, _: LayoutId, _: &Painter, _: &Layout<Self::Signal, A>) -> Vec2 {
		self.inner.size
	}

	fn event_handle_strategy(&self) -> EventHandleStrategy {
		self.inner.event_handle_strategy
	}
}