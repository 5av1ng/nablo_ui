//! A simple label widget for displaying text.

use crate::{layout::{Layout, LayoutId}, prelude::{FillMode, FontId, InputState, Painter, Rect, Vec2}, App};

use super::{styles::{CONTENT_TEXT_SIZE, PRIMARY_TEXT_COLOR, SECONDARY_TEXT_COLOR, TITLE_TEXT_SIZE}, Signal, SignalGenerator, Widget};

/// A simple label widget for displaying text.
pub struct Label<S: Signal, A: App<Signal = S>> {
	/// The inner properties of the label.
	pub inner: LabelInner,
	/// The signals generated by the label.
	pub signals: SignalGenerator<S, LabelInner, A>,
	inner_size: Vec2,
}

/// A struct determings the inner properties of the label.
#[derive(Clone, Debug, PartialEq)]
pub struct LabelInner {
	/// The text to display.
	pub text: String,
	/// The style of the label.
	pub style: LabelStyle,
	/// The font id of the text.
	pub font: FontId,
	/// The size of the label.
	/// 
	/// Will automatically adjust to fit the text if not set.
	/// 
	/// Will add break if the text is too long to fit in the size.
	pub size: Option<Vec2>,
	/// Whether to allow break in the middle of a word.
	pub allow_break_in_word: bool,
	/// Whether to automatically break the text to fit the size.
	pub auto_break: bool,
}

impl Default for LabelInner {
	fn default() -> Self {
		Self {
			text: String::new(),
			style: LabelStyle::Content,
			font: 0,
			size: None,
			allow_break_in_word: true,
			auto_break: false,
		}
	}
}

/// The style of the label.
#[derive(Clone, Debug, PartialEq, Default)]
pub enum LabelStyle {
	/// A label with a title style.
	Title,
	/// A label with a content style.
	#[default] Content,
	/// A label with a custom style.
	Custom {
		font_size: f32,
		color: FillMode,
	},
}

impl<S: Signal, A: App<Signal = S>> Default for Label<S, A> {
	fn default() -> Self {
		Self {
			inner: LabelInner::default(),
			signals: SignalGenerator::default(),
			inner_size: Vec2::ZERO,
		}
	}
}

impl<S: Signal, A: App<Signal = S>> Label<S, A> {
	/// Creates a new label with the given text.
	pub fn new(text: impl Into<String>) -> Self {
		Self {
			inner: LabelInner {
				text: text.into(),
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Creates a new title label with the given text.
	pub fn title(text: impl Into<String>) -> Self {
		Self {
			inner: LabelInner {
				text: text.into(),
				style: LabelStyle::Title,
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Sets whether to allow break in the middle of a word.
	pub fn allow_break_in_word(self, allow_break_in_word: bool) -> Self {
		Self { inner: LabelInner { allow_break_in_word, ..self.inner }, ..self }
	}

	/// Sets whether to automatically break the text to fit the size.
	pub fn auto_break(self, auto_break: bool) -> Self {
		Self { inner: LabelInner { auto_break, ..self.inner }, ..self }
	}

	/// Sets the font of the label.
	pub fn font(self, font: FontId) -> Self {
		Self { inner: LabelInner { font, ..self.inner }, ..self }
	}

	/// Sets the size of the label.
	pub fn set_size(self, size: Vec2) -> Self {
		Self { inner: LabelInner { size: Some(size), ..self.inner }, ..self }
	}

	/// Sets the style of the label.
	pub fn style(self, style: LabelStyle) -> Self {
		Self { inner: LabelInner { style, ..self.inner }, ..self }
	}

	/// Sets the text of the label.
	pub fn text(self, text: impl Into<String>) -> Self {
		Self { inner: LabelInner { text: text.into(), ..self.inner }, ..self }
	}

	fn auto_break_func(&mut self, painter: &Painter) {
		let size = if let Some(size) = self.inner.size {
			size
		}else {
			if self.inner_size == Vec2::ZERO {
				return;
			}
			self.inner_size
		};

		let font_size = match &self.inner.style {
			LabelStyle::Title => TITLE_TEXT_SIZE,
			LabelStyle::Content => CONTENT_TEXT_SIZE,
			LabelStyle::Custom { font_size, .. } => *font_size,
		};

		// let text_size = painter.text_size(self.font, font_size, &self.text).unwrap_or_default();

		let text = self.inner.text.clone().replace("\n", "");
		let mut out_text = String::new();

		for line in text.lines() {
			let word = if self.inner.allow_break_in_word {
				line.chars().map(|inner| inner.to_string()).collect::<Vec<_>>()
			}else {
				line.split_whitespace().map(|inner| inner.to_string()).collect::<Vec<_>>()
			};

			let mut new_text = String::new();
			let mut current_width = 0.0;
			for word in word {
				let word_size = painter.text_size(self.inner.font, font_size, &word).unwrap_or_default();
				if word_size.x + current_width <= size.x {
					new_text.push_str(&word);
					current_width += word_size.x;
				}else {
					new_text.push('\n');
					new_text.push_str(&word);
					current_width = word_size.x;
				}
			}
			out_text.push_str(&new_text);
			out_text.push('\n');
		}

		self.inner.text = out_text.trim().to_string();
	}
}

impl<S: Signal, A: App<Signal = S>> Widget for Label<S, A> {
	type Signal = S;
	type Application = A;

	fn size(&self, _: LayoutId, painter: &Painter, _: &Layout<Self::Signal, A>) -> Vec2 {
		if let Some(size) = self.inner.size {
			size
		}else {
			let font_size = match &self.inner.style {
				LabelStyle::Title => TITLE_TEXT_SIZE,
				LabelStyle::Content => CONTENT_TEXT_SIZE,
				LabelStyle::Custom { font_size, .. } => *font_size,
			};

			painter
			.text_size(self.inner.font, font_size, &self.inner.text)
			.unwrap_or_default()
			.min_both(if self.inner_size == Vec2::ZERO {
				Vec2::INF
			}else {
				self.inner_size
			})
		}.min(painter.window_size)
	}

	fn draw(&mut self, painter: &mut Painter, size: Vec2) {
		if self.inner.auto_break && self.inner_size != size {
			self.inner_size = size;
			self.auto_break_func(painter);
		}

		let (font_size, font_fill) = match &self.inner.style {
			LabelStyle::Title => (TITLE_TEXT_SIZE, FillMode::from(PRIMARY_TEXT_COLOR)),
			LabelStyle::Content => (CONTENT_TEXT_SIZE, FillMode::from(SECONDARY_TEXT_COLOR)),
			LabelStyle::Custom { font_size, color } => (*font_size, color.clone()),
		};

		painter.set_fill_mode(font_fill);

		painter.draw_text(Vec2::ZERO, self.inner.font, font_size, &self.inner.text);
	}

	fn handle_event(&mut self, app: &mut A, input_state: &mut InputState<Self::Signal>, from: LayoutId, area: Rect, _: Vec2) -> bool {
		// self.inner_size = area.size();
		self.signals.generate_signals(app, &mut self.inner, input_state, from, area, false, false);

		false
	}

	fn continuous_event_handling(&self) -> bool {
		false
	}
}