//! A radio button widget for Nablo.

use crate::{layout::{Layout, LayoutId}, prelude::{Animatedf32, Color, FillMode, FontId, InputState, Painter, Rect, Vec2, Vec4}};

use super::{styles::{BRIGHT_FACTOR, CARD_BORDER_COLOR, CONTENT_TEXT_SIZE, DEFAULT_ROUNDING, PRIMARY_COLOR, PRIMARY_TEXT_COLOR, SECONDARY_TEXT_COLOR}, Signal, SignalGenerator, Widget};

const RADIO_SHIRNK_FACTOR: f32 = 0.6;

/// A radio button widget for Nablo.
pub struct Radio<S: Signal> {
	/// The inner properties of the radio button.
	pub inner: RadioInner,
	/// The signal generated by the radio button.
	pub signals: SignalGenerator<S, RadioInner>,
	hover_factor: Animatedf32,
	pressed_factor: Animatedf32,
	clicked_factor: Animatedf32,
}

impl<S: Signal> Default for Radio<S> {
	fn default() -> Self {
		Self {
			inner: RadioInner::default(),
			signals: SignalGenerator::default(),
			hover_factor: Animatedf32::default(),
			pressed_factor: Animatedf32::default(),
			clicked_factor: Animatedf32::default(),
		}
	}
}

/// The inner properties of a radio button.
#[derive(Clone, Debug, PartialEq)]
pub struct RadioInner {
	/// The text of the radio button.
	pub text: String,
	/// The style of the radio button.
	pub style: RadioStyle,
	/// Whether the radio button is selected.
	pub selected: bool,
	/// The font of the radio button.
	pub font: FontId,
	/// The font size of the radio button.
	pub font_size: f32,
	/// The padding of the radio button.
	pub padding: Vec2,
	/// The color of the text of the radio button.
	pub text_color: FillMode,
}

impl Default for RadioInner {
	fn default() -> Self {
		Self {
			text: String::new(),
			style: RadioStyle::default(),
			selected: false,
			font: 0,
			font_size: CONTENT_TEXT_SIZE,
			padding: Vec2::same(DEFAULT_ROUNDING),
			text_color: FillMode::Color(SECONDARY_TEXT_COLOR),
		}
	}
}

/// The style of a radio button.
#[derive(Clone, Debug, PartialEq)]
pub enum RadioStyle {
	/// Classic style of radio button, with a circle and a check mark.
	/// 
	/// Contains the color when it is selected.
	Radio(FillMode),
	/// Style of radio button with a square.
	/// 
	/// Contains the color when it is selected.
	CheckBox(FillMode),
	/// Switch style of radio button, with a circle and a toggle.
	Switch {
		/// The color of the circle.
		circle_color: Color,
		/// The color of the background when it is selected.
		selected_color: Color,
		/// The color of the background when it is not selected.
		unselected_color: Color,
	},
	/// Style of radio button with a button-like appearance.
	Button {
		/// The color of the background when it is selected.
		selected_color: Color,
		/// The color of the background when it is not selected.
		unselected_color: Color,
		/// The roundings of the radio button.
		roundings: Vec4,
	}
}

impl Default for RadioStyle {
	fn default() -> Self {
		RadioStyle::Radio(FillMode::Color(PRIMARY_COLOR))
	}
}

impl<S: Signal> Radio<S> {
	/// Creates a new radio button with text
	pub fn new_radio(text: impl Into<String>) -> Self {
		Self {
			inner: RadioInner {
				text: text.into(),
				text_color: SECONDARY_TEXT_COLOR.into(),
				style: RadioStyle::Radio(PRIMARY_COLOR.into()),
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Creates a new check box button with text
	pub fn new_check_box(text: impl Into<String>) -> Self {
		Self {
			inner: RadioInner {
				text: text.into(),
				text_color: SECONDARY_TEXT_COLOR.into(),
				style: RadioStyle::CheckBox(PRIMARY_COLOR.into()),
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Creates a new switch button with text
	pub fn new_switch(text: impl Into<String>) -> Self {
		Self {
			inner: RadioInner {
				text: text.into(),
				text_color: SECONDARY_TEXT_COLOR.into(),
				style: RadioStyle::Switch {
					circle_color: PRIMARY_TEXT_COLOR,
					selected_color: PRIMARY_COLOR,
					unselected_color: CARD_BORDER_COLOR,
				},
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Creates a new selectable button with text
	pub fn new_button(text: impl Into<String>, ) -> Self {
		Self {
			inner: RadioInner {
				text_color: PRIMARY_TEXT_COLOR.into(),
				text: text.into(),
				style: RadioStyle::Button {
					selected_color: PRIMARY_COLOR,
					unselected_color: CARD_BORDER_COLOR,
					roundings: Vec4::same(DEFAULT_ROUNDING),
				},
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Set whether the radio button is selected.
	pub fn selected(self, selected: bool) -> Self {
		Self {
			inner: RadioInner {
				selected,
				..self.inner
			},
			..self
		}
	}

	/// Set the font of the radio button.
	pub fn font(self, font: FontId) -> Self {
		Self {
			inner: RadioInner {
				font,
				..self.inner
			},
			..self
		}
	}

	/// Set the font size of the radio button.
	pub fn font_size(self, font_size: f32) -> Self {
		Self {
			inner: RadioInner {
				font_size,
				..self.inner
			},
			..self
		}
	}

	/// Set current butten to radio style.
	pub fn radio(self, color: impl Into<FillMode>) -> Self {
		Self {
			inner: RadioInner {
				style: RadioStyle::Radio(color.into()),
				..self.inner
			},
			..self
		}
	}

	/// Set current butten to check box style.
	pub fn check_box(self, color: impl Into<FillMode>) -> Self {
		Self {
			inner: RadioInner {
				style: RadioStyle::CheckBox(color.into()),
				..self.inner
			},
			..self
		}
	}

	/// Set current butten to switch style.
	pub fn switch(self, circle_color: impl Into<Color>, selected_color: impl Into<Color>, unselected_color: impl Into<Color>) -> Self {
		Self {
			inner: RadioInner {
				style: RadioStyle::Switch {
					circle_color: circle_color.into(),
					selected_color: selected_color.into(),
					unselected_color: unselected_color.into(),
				},
				..self.inner
			},
			..self
		}
	}

	/// Set current butten to button style.
	pub fn button(
		self, 
		selected_color: impl Into<Color>, 
		unselected_color: impl Into<Color>, 
		roundings: impl Into<Vec4>, 
	) -> Self {
		Self {
			inner: RadioInner {
				style: RadioStyle::Button {
					selected_color: selected_color.into(),
					unselected_color: unselected_color.into(),
					roundings: roundings.into(),
				},
				..self.inner
			},
			..self
		}
	}

	/// Set the padding of the radio button.
	pub fn padding(self, padding: impl Into<Vec2>) -> Self {
		Self {
			inner: RadioInner {
				padding: padding.into(),
				..self.inner
			},
			..self
		}
	}

	/// Set the color of the text of the radio button.
	pub fn text_color(self, color: impl Into<FillMode>) -> Self {
		Self {
			inner: RadioInner {
				text_color: color.into(),
				..self.inner
			},
			..self
		}
	}

	/// Set the value of the radio button.
	pub fn value(self, selected: bool) -> Self {
		Self {
			inner: RadioInner {
				selected,
				..self.inner
			},
			..self
		}
	}
}

impl<S: Signal> Widget for Radio<S> {
	type Signal = S;

	fn draw(&mut self, painter: &mut Painter, size: Vec2) {
		let bright_factor = self.hover_factor.value() * BRIGHT_FACTOR - self.pressed_factor.value() * BRIGHT_FACTOR;
		let mut text_color = self.inner.text_color.clone();
		text_color.brighter(bright_factor);
		
		match &self.inner.style {
			RadioStyle::Radio(color) => {		
				painter.set_fill_mode(text_color);
				painter.draw_stroked_circle(
					Vec2::same(self.inner.font_size) / 2.0,
					self.inner.font_size / 2.0 - 0.75, 
					1.5
				);
				let text_pos = Vec2::new(self.inner.font_size + self.inner.padding.x, 0.0);
				painter.draw_text(text_pos, self.inner.font, self.inner.font_size, &self.inner.text);
				let mut color = color.clone();
				color.brighter(bright_factor);
				color.mul_alpha(self.clicked_factor.value());
				painter.set_fill_mode(color);
				painter.draw_circle(Vec2::same(self.inner.font_size) / 2.0, self.inner.font_size / 2.0 * RADIO_SHIRNK_FACTOR);
			},
			RadioStyle::CheckBox(color) => {
				painter.set_fill_mode(text_color);
				painter.draw_stroked_rect(
					Rect::from_size(Vec2::same(self.inner.font_size)).shrink(Vec2::same(0.75)),
					Vec4::same(2.0), 
					1.5
				);
				let text_pos = Vec2::new(self.inner.font_size + self.inner.padding.x, 0.0);
				painter.draw_text(text_pos, self.inner.font, self.inner.font_size, &self.inner.text);
				let mut color = color.clone();
				color.brighter(bright_factor);
				color.mul_alpha(self.clicked_factor.value());
				painter.set_fill_mode(color);
				painter.draw_rect(
					Rect::from_size(Vec2::same(self.inner.font_size))
						.shrink(Vec2::same(self.inner.font_size) * (1.0 - RADIO_SHIRNK_FACTOR) / 2.0),
					Vec4::same(2.0), 
				);
			},
			RadioStyle::Switch { circle_color, selected_color, unselected_color } => {
				let unselected_color = unselected_color.brighten(bright_factor);
				let selected_color = selected_color.brighten(bright_factor);
				let circle_color = circle_color.brighten(bright_factor);

				let factor = self.clicked_factor.value();
				let background_color = unselected_color.lerp(selected_color, factor);

				painter.set_fill_mode(background_color);
				painter.draw_rect(
					Rect::from_size(Vec2::new(self.inner.font_size * 2.0, self.inner.font_size)), 
					Vec4::same(self.inner.font_size / 2.0)
				);

				painter.set_fill_mode(circle_color);
				let cir_pos = Vec2::same(self.inner.font_size / 2.0) + factor * Vec2::x(self.inner.font_size);
				painter.draw_circle(cir_pos, self.inner.font_size / 2.0 * 0.8);

				painter.set_fill_mode(text_color);
				let text_pos = Vec2::new(self.inner.font_size * 2.0 + self.inner.padding.x, 0.0);
				painter.draw_text(text_pos, self.inner.font, self.inner.font_size, &self.inner.text);
			},
			RadioStyle::Button { selected_color, unselected_color, roundings } => {
				let selected_color = selected_color.brighten(bright_factor);
				let unselected_color = unselected_color.brighten(bright_factor);
				
				let factor = self.clicked_factor.value();

				let background_color = unselected_color.lerp(selected_color, factor);

				painter.set_fill_mode(background_color);
				painter.draw_rect(
					Rect::from_size(size),
					*roundings,
				);

				painter.set_fill_mode(text_color);
				painter.draw_text(
					self.inner.padding,
					self.inner.font,
					self.inner.font_size,
					&self.inner.text,
				);
			},
		}
	}

	fn size(&self, _: LayoutId, painter: &Painter, _: &Layout<Self::Signal>) -> Vec2 {
		let text_size = painter.text_size(self.inner.font, self.inner.font_size, &self.inner.text).unwrap_or_default();
		match &self.inner.style {
			RadioStyle::Radio(_) => {
				Vec2::new(self.inner.font_size + self.inner.padding.x, 0.0) + text_size
			},
			RadioStyle::CheckBox(_) => {
				Vec2::new(self.inner.font_size + self.inner.padding.x, 0.0) + text_size
			},
			RadioStyle::Switch { .. } => {
				Vec2::new(self.inner.font_size * 2.0 + self.inner.padding.x, 0.0) + text_size
			}
			RadioStyle::Button { .. } => {
				text_size + self.inner.padding * 2.0
			}
		}
	}

	fn handle_event(&mut self, input_state: &mut InputState<Self::Signal>, from: LayoutId, area: Rect, _: Vec2) -> bool {
		let res = self.signals.generate_signals(
			&mut self.inner, 
			input_state, 
			from, 
			area, 
			true, 
			false
		);

		if input_state.any_touch_pressing_on(area) {
			self.hover_factor.set(1.0);
		}else {
			self.hover_factor.set(0.0);
		}

		if input_state.any_touch_pressed_on(area) {
			self.pressed_factor.set(1.0);
		}else {
			self.pressed_factor.set(0.0);
		}

		if self.inner.selected {
			self.clicked_factor.set(1.0);
		}else {
			self.clicked_factor.set(0.0);
		}

		if res.is_clicked {
			self.inner.selected = !self.inner.selected;
		}

		self.clicked_factor.is_animating() || self.hover_factor.is_animating() || self.pressed_factor.is_animating()
	}
}