//! A slider widget for the UI.

use crate::{layout::{Layout, LayoutId}, prelude::{Animatedf32, FillMode, FontId, InputState, Painter, Rect, Vec2, Vec4}};

use super::{styles::{BRIGHT_FACTOR, CONTENT_TEXT_SIZE, DEFAULT_PADDING, INPUT_BACKGROUND_COLOR, PRIMARY_COLOR, PRIMARY_TEXT_COLOR}, Signal, SignalGenerator, Widget};

/// A slider widget for the UI.
pub struct Slider<S: Signal> {
	/// The inner properties of the slider.
	pub inner: SliderInner,
	/// The signals generated by the slider.
	pub signals: SignalGenerator<S, SliderInner>,
	// cumulative_drag_delta: f32,
	hover_factor: Animatedf32,
	pressed_factor: Animatedf32,
}

/// The inner properties of the slider.
#[derive(Clone, Debug, PartialEq)]
pub struct SliderInner {
	/// The current value of the slider.
	pub value: f32,
	/// The minimum value of the slider.
	pub min: f32,
	/// The maximum value of the slider.
	pub max: f32,
	// /// The step size of the slider.
	// pub step: f32,
	/// Whether the slider is logarithmic.
	pub is_logarithmic: bool,
	/// The length of the slider.
	pub length: f32,
	/// The background color of the slider.
	pub background_color: FillMode,
	/// The foreground color of the slider.
	pub foreground_color: FillMode,
	/// The circle color of the slider.
	pub circle_color: FillMode,
	/// The prefix of the slider.
	pub prefix: String,
	/// The suffix of the slider.
	pub suffix: String,
	/// The font size of the slider.
	pub font_size: f32,
	/// The font color of the slider.
	pub font_color: FillMode,
	/// The font of the slider.
	pub font: FontId,
	/// Whether to show the text on the left of the slider.
	pub text_left: bool,
	/// Whether to fill foreground color in the reverse direction.
	pub reverse: bool,
	/// The padding of the slider.
	pub padding: f32,
	/// The number of decimal places to display.
	pub decimal_places: usize,
}

impl Default for SliderInner {
	fn default() -> Self {
		Self {
			value: 0.0,
			min: 0.0,
			max: 1.0,
			// step: 0.01,
			is_logarithmic: false,
			length: 100.0,
			background_color: FillMode::Color(INPUT_BACKGROUND_COLOR),
			foreground_color: FillMode::Color(PRIMARY_COLOR),
			circle_color: FillMode::Color(PRIMARY_TEXT_COLOR),
			prefix: "".to_string(),
			suffix: "".to_string(),
			font_size: CONTENT_TEXT_SIZE,
			font_color: FillMode::Color(PRIMARY_TEXT_COLOR),
			font: 0,
			text_left: false,
			reverse: false,
			padding: DEFAULT_PADDING,
			decimal_places: 2,
		}
	}
}

impl<S: Signal> Default for Slider<S> {
	fn default() -> Self {
		Self {
			inner: Default::default(),
			signals: Default::default(),
			// cumulative_drag_delta: 0.0,
			hover_factor: Animatedf32::default(),
			pressed_factor: Animatedf32::default(),
		}
	}
}

impl<S: Signal> Slider<S> {
	/// Creates a new slider with default values.
	/// 
	/// # Panics
	/// 
	/// Panics if `min` is greater than `max`.
	/// Panics if `value` is not between `min` and `max`.
	pub fn new(value: f32, min: f32, max: f32) -> Self {
		assert!(min < max, "min must be less than max");
		assert!(min <= value && value <= max, "value must be between min and max");
		let step  = (max - min) / 100.0;
		let decimal_places = step.log10().floor() as usize;
		Self {
			inner: SliderInner {
				value,
				min,
				max,
				// step,
				decimal_places,
				..Default::default()
			},
			..Default::default()
		}
	}

	/// Sets the minimum value of the slider.
	pub fn min(self, min: f32) -> Self {
		Self {
			inner: SliderInner { min, ..self.inner },
			..self
		}
	}

	/// Sets the maximum value of the slider.
	pub fn max(self, max: f32) -> Self {
		Self {
			inner: SliderInner { max, ..self.inner },
			..self
		}
	}

	/// Sets the value of the slider.
	pub fn value(self, value: f32) -> Self {
		Self {
			inner: SliderInner { value, ..self.inner },
			..self
		}
	}

	/// Sets whether the slider is logarithmic.
	pub fn logarithmic(self, is_logarithmic: bool) -> Self {
		Self {
			inner: SliderInner { is_logarithmic, ..self.inner },
			..self
		}
	}

	// /// Sets the step size of the slider.
	// pub fn step(self, step: f32) -> Self {
	// 	Self {
	// 		inner: SliderInner { step,..self.inner },
	// 		..self
	// 	}
	// }

	/// Sets the length of the slider.
	pub fn length(self, length: f32) -> Self {
		Self {
			inner: SliderInner { length, ..self.inner },
			..self
		}
	}

	/// Sets the background color of the slider.
	pub fn background_color(self, background_color: impl Into<FillMode>) -> Self {
		Self {
			inner: SliderInner { background_color: background_color.into(), ..self.inner },
			..self
		}
	}

	/// Sets the foreground color of the slider.
	pub fn foreground_color(self, foreground_color: impl Into<FillMode>) -> Self {
		Self {
			inner: SliderInner { foreground_color: foreground_color.into(), ..self.inner },
			..self
		}
	}

	/// Sets the circle color of the slider.
	pub fn circle_color(self, circle_color: impl Into<FillMode>) -> Self {
		Self {
			inner: SliderInner { circle_color: circle_color.into(), ..self.inner },
			..self
		}
	}

	/// Sets the prefix of the slider.
	pub fn prefix(self, prefix: impl Into<String>) -> Self {
		Self {
			inner: SliderInner { prefix: prefix.into(), ..self.inner },
			..self
		}
	}

	/// Sets the suffix of the slider.
	pub fn suffix(self, suffix: impl Into<String>) -> Self {
		Self {
			inner: SliderInner { suffix: suffix.into(), ..self.inner },
			..self
		}
	}

	/// Sets the font size of the slider.
	pub fn font_size(self, font_size: f32) -> Self {
		Self {
			inner: SliderInner { font_size, ..self.inner },
			..self
		}
	}

	/// Sets the font color of the slider.
	pub fn font_color(self, font_color: impl Into<FillMode>) -> Self {
		Self {
			inner: SliderInner { font_color: font_color.into(), ..self.inner },
			..self
		}
	}

	/// Sets the font of the slider.
	pub fn font(self, font: FontId) -> Self {
		Self {
			inner: SliderInner { font, ..self.inner },
			..self
		}
	}

	/// Sets whether to show the text on the left of the slider.
	pub fn text_left(self, text_left: bool) -> Self {
		Self {
			inner: SliderInner { text_left, ..self.inner },
			..self
		}
	}

	/// Sets whether to fill foreground color in the reverse direction.
	pub fn reverse(self, reverse: bool) -> Self {
		Self {
			inner: SliderInner { reverse, ..self.inner },
			..self
		}
	}

	/// Sets the padding of the slider.
	pub fn padding(self, padding: f32) -> Self {
		Self {
			inner: SliderInner { padding, ..self.inner },
			..self
		}
	}

	/// Sets the number of decimal places to display.
	pub fn decimal_places(self, decimal_places: usize) -> Self {
		Self {
			inner: SliderInner { decimal_places, ..self.inner },
			..self
		}
	}
}

impl<S: Signal> Widget for Slider<S> {
	type Signal = S;

	fn size(&self, _: LayoutId, painter: &Painter, _: &Layout<Self::Signal>) -> Vec2 {
		let text_to_draw = format!("{}{:.3$}{}", 
			self.inner.prefix, 
			self.inner.value, 
			self.inner.suffix, 
			self.inner.decimal_places
		);
		let text_size = painter.text_size(self.inner.font, self.inner.font_size, text_to_draw).unwrap_or_default();

		let padding = self.inner.padding;

		Vec2::x(self.inner.length + padding * 2.0) + text_size
	}

	fn draw(&mut self, painter: &mut Painter, size: Vec2) {
		let bright_factor = BRIGHT_FACTOR * (self.hover_factor.value() - self.pressed_factor.value()).max(0.0); 

		let text_to_draw = format!("{}{:.3$}{}", 
			self.inner.prefix, 
			self.inner.value, 
			self.inner.suffix, 
			self.inner.decimal_places
		);

		let text_size = painter.text_size(self.inner.font, self.inner.font_size, &text_to_draw).unwrap_or_default();
		let padding = self.inner.padding;
		let length = self.inner.length;
		let circle_radius = self.inner.font_size / 2.0;
		
		let text_pos = if self.inner.text_left {
			Vec2::new(padding, (size.y - text_size.y) / 2.0)
		}else {
			Vec2::new(padding * 2.0 + length, (size.y - text_size.y) / 2.0)
		};

		let slider_pos = if self.inner.text_left {
			Vec2::new(padding * 2.0 + text_size.x, size.y / 2.0)
		}else {
			Vec2::new(padding, size.y / 2.0)
		};

		let circle_pos = {
			let factor = if self.inner.is_logarithmic {
				(self.inner.value.log10() - self.inner.min.log10()) / (self.inner.max.log10() - self.inner.min.log10())
			}else {
				(self.inner.value - self.inner.min) / (self.inner.max - self.inner.min)
			};
			let length = length * factor;
			let x = slider_pos.x + length;
			Vec2::new(x, slider_pos.y)
		};

		let mut background_color = self.inner.background_color.clone();
		let mut foreground_color = self.inner.foreground_color.clone();
		let mut circle_color = self.inner.circle_color.clone();

		background_color.brighter(bright_factor);
		foreground_color.brighter(bright_factor);
		circle_color.brighter(bright_factor);

		let rect_size = circle_radius / 2.0;
		painter.set_fill_mode(background_color);
		painter.draw_rect(Rect::from_lt_size(
			slider_pos - Vec2::y(rect_size / 2.0), 
			Vec2::new(length, rect_size),
		), Vec4::same(rect_size / 2.0));

		painter.set_fill_mode(foreground_color);
		if self.inner.reverse {
			painter.draw_rect(Rect::from_ltrb(
				circle_pos - Vec2::y(rect_size / 2.0), 
				slider_pos + Vec2::new(length, rect_size / 2.0),
			), Vec4::same(rect_size / 2.0));
		}else {
			painter.draw_rect(Rect::from_ltrb(
				slider_pos - Vec2::y(rect_size / 2.0), 
				circle_pos + Vec2::y(rect_size / 2.0),
			), Vec4::same(rect_size / 2.0));
		}

		painter.set_fill_mode(circle_color);
		painter.draw_circle(circle_pos, circle_radius);

		painter.draw_text(text_pos, self.inner.font, self.inner.font_size, text_to_draw);
	}

	fn handle_event(&mut self, input_state: &mut InputState<Self::Signal>, from: LayoutId, area: Rect, _: Vec2) -> bool {
		let res = self.signals.generate_signals(&mut self.inner, input_state, from, area, true, true);
		
		if input_state.any_touch_pressing_on(area) {
			self.hover_factor.set(1.0);
		}else {
			self.hover_factor.set(0.0);
		}
		
		if input_state.any_touch_pressing_on(area) && input_state.is_any_touch_pressed() {
			self.pressed_factor.set(1.0);
		}

		if input_state.is_any_touch_released() {
			self.pressed_factor.set(0.0);
		}
		
		let changed = if let Some(delta) = res.drag_delta {
			let step = delta.x / self.inner.length;
			let step = if self.inner.is_logarithmic {
				step * (self.inner.max.log10() - self.inner.min.log10())
			}else {
				step * (self.inner.max - self.inner.min)
			};
			self.inner.value = if self.inner.is_logarithmic {
				10.0_f32.powf(self.inner.value.log10() + step)
			}else {
				self.inner.value + step
			};
			self.inner.value = self.inner.value.clamp(self.inner.min, self.inner.max);
			delta.x != 0.0
		}else {
			false
		};

		self.pressed_factor.is_animating() || self.hover_factor.is_animating() || changed
	}
}