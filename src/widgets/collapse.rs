//! A widget that can be collapsed or expanded.

use std::{collections::HashMap, f32::consts::PI};

use indexmap::IndexMap;

use crate::{layout::{Layout, LayoutId}, prelude::{Animatedf32, FillMode, FontId, InputState, Painter, Rect, Transform2D, Vec2, Vec4}, App};

use super::{styles::{CARD_BORDER_COLOR, CONTENT_TEXT_SIZE, SECONDARY_TEXT_COLOR}, Signal, SignalGenerator, Widget};

/// A widget that can be collapsed or expanded.
/// 
/// Note: You need set click event by using [`Self::on_click`] to use this widget correctly.
pub struct Collapse<S: Signal, A: App<Signal = S>> {
	/// The inner property of the `Collapse` widget.
	pub inner: CollapseInner,
	/// signals generated by the widget.
	pub signals: SignalGenerator<S, CollapseInner, A>,
	rotate_factor: Animatedf32,
	inner_size: Vec2,
	title_size: Vec2,
}

/// The inner property of the `Collapse` widget.
#[derive(Debug, PartialEq, Clone)]
pub struct CollapseInner {
	/// The font id of the title.
	pub font: FontId,
	/// The font size of the title.
	pub font_size: f32,
	/// The padding of each element.
	pub padding: f32,
	/// The font color of the title.
	pub font_color: FillMode,
	/// Whether the widget is currently collapsed or expanded.
	pub collapsed: bool,
	/// The title of the widget.
	pub title: String,
}

impl Default for CollapseInner {
	fn default() -> Self {
		Self {
			font: 0,
			font_size: CONTENT_TEXT_SIZE,
			padding: CONTENT_TEXT_SIZE,
			font_color: FillMode::Color(SECONDARY_TEXT_COLOR),
			collapsed: true,
			title: String::new(),
		}
	}
}

impl<S: Signal, A: App<Signal = S>> Collapse<S, A> {
	/// Creates a new `Collapse` widget.
	pub fn new(title: impl Into<String>) -> Self {
		Self {
			inner: CollapseInner {
				title: title.into(),
				..CollapseInner::default()
			},
			signals: SignalGenerator::default(),
			rotate_factor: Animatedf32::default(),
			title_size: Vec2::ZERO,
			inner_size: Vec2::ZERO,
		}
	}

	/// toggles the collapse state of the widget.
	pub fn toggle_collapse(&mut self) {
		self.inner.collapsed = !self.inner.collapsed;
		self.rotate_factor.set(if self.inner.collapsed { 0.0 } else {  PI / 2.0  });
		self.inner_size = Vec2::ZERO;
	}

	/// sets the collapse state of the widget.
	pub fn collapse(self, collapsed: bool) -> Self {
		Self {
			inner: CollapseInner { collapsed, ..self.inner },
			..self
		}
	}

	/// sets the title of the widget.
	pub fn title(self, title: impl Into<String>) -> Self {
		Self {
			inner: CollapseInner { title: title.into(), ..self.inner },
			..self
		}
	}

	/// sets the font id of the title.
	pub fn font(self, font: FontId) -> Self {
		Self {
			inner: CollapseInner { font, ..self.inner },
			..self
		}
	}

	/// sets the font size of the title.
	pub fn font_size(self, font_size: f32) -> Self {
		Self {
			inner: CollapseInner { font_size, ..self.inner },
			..self
		}
	}

	/// sets the padding of each element.
	pub fn padding(self, padding: f32) -> Self {
		Self {
			inner: CollapseInner { padding, ..self.inner },
			..self
		}
	}

	/// sets the font color of the title.
	pub fn font_color(self, font_color: impl Into<FillMode>) -> Self {
		Self {
			inner: CollapseInner { font_color: font_color.into(), ..self.inner },
			..self
		}
	}
}

impl<S: Signal, A: App<Signal = S>> Widget for Collapse<S, A> {
	type Signal = S;
	type Application = A;

	fn handle_event(&mut self, app: &mut A, input_state: &mut InputState<Self::Signal>, id: LayoutId, area: Rect, _: Vec2) -> bool {
		let cursor_pos = input_state.touch_positions();
		let title_area = Rect::from_lt_size(area.lt(), self.title_size);
		let should_switch = cursor_pos.iter().any(|pos| title_area.contains(*pos)) 
			&& self.signals.generate_signals(
				app,
				&mut self.inner, 
				input_state, 
				id,
				area, 
				true, 
				false
			).is_clicked;
		if should_switch {
			// println!("clicked");
			self.toggle_collapse();
		}

		self.rotate_factor.is_animating()
	}

	fn size(&self, _: LayoutId, painter: &Painter, _: &Layout<Self::Signal, A>) -> Vec2 {
		let title_size = Vec2::x(self.inner.font_size) + painter.text_size(self.inner.font, self.inner.font_size, &self.inner.title).unwrap_or(Vec2::ZERO);
		if self.inner.collapsed || self.inner_size == Vec2::ZERO {
			title_size
		}else {
			self.inner_size
		}
	}

	fn draw(&mut self, painter: &mut Painter, _: Vec2) {
		let size = painter.clip_rect().rb() - painter.releative_to();
		let title_size = painter.text_size(self.inner.font, self.inner.font_size, &self.inner.title).unwrap_or(Vec2::ZERO);
		self.title_size = title_size + Vec2::same(self.inner.font_size);
		if !self.inner.collapsed {
			painter.set_fill_mode(CARD_BORDER_COLOR);
			painter.draw_rect(
				Rect::from_lt_size(
					Vec2::new(self.inner.font_size / 2.0 - 1.0, self.inner.font_size + self.inner.padding), 
					Vec2::new(2.0, size.y - self.inner.font_size - self.inner.padding)
				),
				Vec4::ZERO,
			);
		}
		painter.set_fill_mode(self.inner.font_color.clone());
		painter.draw_text(Vec2::x(self.inner.font_size), self.inner.font, self.inner.font_size, &self.inner.title);
		let transform = Transform2D::translate(painter.releative_to())
			>> Transform2D::translate(Vec2::same(self.inner.font_size / 2.0))
			>> Transform2D::scale(Vec2::same(0.5))
			>> Transform2D::rotate(self.rotate_factor.value())
			>> Transform2D::translate(Vec2::same(-self.inner.font_size / 2.0))
			>> Transform2D::translate(-painter.releative_to());
		painter.set_transform(transform);
		painter.draw_triangle(Vec2::ZERO, Vec2::new(self.inner.font_size, self.inner.font_size / 2.0), Vec2::y(self.inner.font_size));
	}

	fn handle_child_layout(&mut self, childs: IndexMap<LayoutId, Vec2>, _: Rect, _: LayoutId) -> HashMap<LayoutId, Option<Rect>> {
		if self.inner.collapsed {
			return HashMap::new();
		}

		let mut inner_size = self.title_size;
		let mut layout = HashMap::new();
		
		for (id, size) in childs {
			// inner_size.y += ;
			let rect = Rect::from_lt_size(Vec2::new(self.inner.padding, inner_size.y), size);
			layout.insert(id, rect);
			inner_size.y += size.y + self.inner.padding;
			inner_size.x = rect.w.max(inner_size.x);
		}
		
		self.inner_size = inner_size - Vec2::y(self.inner.padding);
		// println!("{inner_size}");
		layout.into_iter().map(|(id, rect)| (id, Some(rect))).collect()
	}

	fn inner_padding(&self) -> Vec2 {
		Vec2::same(self.inner.padding)
	}
}