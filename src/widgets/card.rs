//! A simple card container supporting scrolling and different layout for displaying other widgets.

use std::collections::HashMap;

use crate::{layout::{Layout, LayoutId}, math::{color::Vec4, prelude::Animatedf32, rect::Rect, vec2::Vec2}, prelude::{Animation, AnimationNode, Linker, BACKGROUND_COLOR, DEFAULT_ANIMATION_DURATION, PRIMARY_COLOR}, render::{painter::Painter, shape::FillMode}, window::input_state::InputState};

use super::{styles::{CARD_BORDER_COLOR, CARD_COLOR, DEFAULT_ROUNDING}, Signal, SignalGenerator, Widget};

/// A simple card container for displaying other widgets.
/// 
/// Note: You need set drag signal by [`Self::on_drag`] to use scrolling correctly.
pub struct Card<S: Signal> {
	/// The inner properties of the card.
	pub inner: CardInner,
	/// The signals generated by the card.
	pub signals: SignalGenerator<S, CardInner>,
	actual_size: Vec2,
	inner_size: Vec2,
}

/// The inner properties of the card.
#[derive(Debug, PartialEq)]
pub struct CardInner {
	/// The layout strategy to use for the card.
	pub layout_strategy: LayoutStrategy,
	/// Set position of a child widget maually instead of using the layout strategy.
	/// 
	/// Will only affect the child with the given `LayoutId`.
	pub fixed_children: HashMap<LayoutId, Vec2>,
	/// Set the background color of the card.
	pub background_color: FillMode,
	/// Set the rounding of the card.
	pub rounding: Vec4,
	/// The size of the card.
	pub size: (Option<f32>, Option<f32>),
	/// Set the scroll state of the card.
	pub scroll: Scroll,
	/// The border color and width of the card.
	pub border: Option<(FillMode, f32)>,
	/// Whether to draw the stroke of the card.
	pub draw_stroke: bool,
	/// dont draw anything related to the card(not including the children).
	pub dont_draw: bool,
}

impl Default for CardInner {
	fn default() -> Self {
		Self {
			layout_strategy: LayoutStrategy::default(),
			fixed_children: HashMap::new(),
			background_color: FillMode::default(),
			rounding: Vec4::same(DEFAULT_ROUNDING),
			size: (None, None),
			scroll: Scroll::default(),
			border: None,
			draw_stroke: true,
			dont_draw: false,
		}
	}
}

impl<S: Signal> Card<S> {
	/// Creates a new card with the given layout strategy.
	pub fn new(layout_strategy: LayoutStrategy) -> Self {
		Self {
			inner: CardInner {
				layout_strategy,
				fixed_children: HashMap::new(),
				background_color: FillMode::from(CARD_COLOR),
				rounding: Vec4::same(DEFAULT_ROUNDING),
				size: (None, None),
				scroll: Scroll::default(),
				border: None,
				draw_stroke: true,
				dont_draw: false,
			},
			signals: Default::default(),
			actual_size: Vec2::ZERO,
			inner_size: Vec2::ZERO,
		}
	}

	/// Creates a new card with vertical layout strategy.
	pub fn new_vertical() -> Self {
		Self::new(LayoutStrategy::default()).typesetting(Typesetting::Vertical)
	}

	/// Creates a new card with horizontal layout strategy.
	pub fn new_horizontal() -> Self {
		Self::new(LayoutStrategy::default()).typesetting(Typesetting::Horizontal)
	}

	/// Sets whether to draw the stroke of the card.
	pub fn draw_stroke(self, draw_stroke: bool) -> Self {
		Self {
			inner: CardInner { draw_stroke, ..self.inner },
			..self
		}
	}

	/// Sets the background color of the card.
	pub fn background_color(self, color: impl Into<FillMode>) -> Self {
		Self {
			inner: CardInner { background_color: color.into(), ..self.inner },
			..self
		}
	}

	/// Sets the rounding of the card.
	pub fn rounding(self, rounding: impl Into<Vec4>) -> Self {
		Self {
			inner: CardInner { rounding: rounding.into(), ..self.inner },
			..self
		}
	}

	/// Sets the border of the card.
	pub fn border(self, color: impl Into<FillMode>, width: f32) -> Self {
		Self {
			inner: CardInner { border: Some((color.into(), width)), ..self.inner },
			..self
		}
	}

	/// Sets the size of the card.
	pub fn set_size(self, size: impl Into<Vec2>) -> Self {
		let size = size.into();
		Self {
			inner: CardInner { size: (Some(size.x), Some(size.y)), ..self.inner },
			..self
		}
	}

	/// Sets the width of the card.
	pub fn set_width(self, width: f32) -> Self {
		Self {
			inner: CardInner { size: (Some(width), None), ..self.inner },
			..self
		}
	}

	/// Sets the height of the card.
	pub fn set_height(self, height: f32) -> Self {
		Self {
			inner: CardInner { size: (None, Some(height)), ..self.inner },
			..self
		}
	}

	/// Sets the scroll state of the card.
	pub fn scroll(self, scroll: Scroll) -> Self {
		Self {
			inner: CardInner { scroll, ..self.inner },
			..self
		}
	}

	/// Sets the child widget with the given `LayoutId` to a fixed position.
	pub fn pin_child(mut self, id: LayoutId, pos: impl Into<Vec2>) -> Self {
		self.inner.fixed_children.insert(id, pos.into());
		self
	}

	/// Sets the direction of the card contents.
	pub fn direction(self, direction: Direction) -> Self {
		Self {
			inner: CardInner { layout_strategy: LayoutStrategy {
				direction,
				..self.inner.layout_strategy
			}, ..self.inner },
			..self
		}
	}

	/// sets the typesetting of the card contents.
	pub fn typesetting(self, typesetting: Typesetting) -> Self {
		Self {
			inner: CardInner { layout_strategy: LayoutStrategy {
				typesetting,
				..self.inner.layout_strategy
			}, ..self.inner },
			..self
		}
	}

	/// Sets the alignments of the contents.
	pub fn alignments(self, alignment: [Alignment; 2]) -> Self {
		Self {
			inner: CardInner { layout_strategy: LayoutStrategy {
				alignment,
				..self.inner.layout_strategy
			}, ..self.inner },
			..self
		}
	}

	/// Sets the padding between the contents.
	pub fn padding(self, padding: impl Into<Vec2>) -> Self {
		Self {
			inner: CardInner { layout_strategy: LayoutStrategy {
				padding: padding.into(),
				..self.inner.layout_strategy
			}, ..self.inner },
			..self
		}
	}

	/// Sets whether to draw the any thing related to the card.
	pub fn dont_draw(self, dont_draw: bool) -> Self {
		Self {
			inner: CardInner { dont_draw, ..self.inner },
			..self
		}
	}

	fn scroll_pos(&self) -> Vec2 {
		match &self.inner.scroll {
			Scroll::Off => Vec2::ZERO,
			Scroll::Vertical{current, ..} => Vec2::new(0.0, current.value()),
			Scroll::Horizontal{current, ..} => Vec2::new(current.value(), 0.0),
			Scroll::Both{current_vertical, current_horizontal, ..} => Vec2::new(current_horizontal.value(), current_vertical.value()),
		}
	}
}

impl<S: Signal> Default for Card<S> {
	fn default() -> Self {
		Self {
			inner: Default::default(),
			signals: Default::default(),
			actual_size: Vec2::ZERO,
			inner_size: Vec2::ZERO,
		}
	}
}

/// The scroll state of the card.
#[derive(Debug, PartialEq, Default)]
pub enum Scroll {
	/// Scroll is disabled.
	#[default] Off,
	/// Vertical scroll is enabled.
	Vertical {
		/// The current scroll position.
		current: Animatedf32,
		/// The maximum scroll position.
		///
		/// Set to None to automatically calculate the maximum scroll position based on the size of the contents.
		maximum: Option<f32>,
	},
	/// Horizontal scroll is enabled.
	Horizontal {
		/// The current scroll position.
		current: Animatedf32,
		/// The maximum scroll position.
		/// 
		/// Set to None to automatically calculate the maximum scroll position based on the size of the contents.
		maximum: Option<f32>,
	},
	/// Both vertical and horizontal scroll are enabled.
	Both {
		/// The current scroll position vertically.
		current_vertical: Animatedf32,
		/// The current scroll position horizontally.
		current_horizontal: Animatedf32,
		/// The maximum scroll position vertically.
		/// 
		/// Set to None to automatically calculate the maximum scroll position based on the size of the contents.
		maximum_vertical: Option<f32>,
		/// The maximum scroll position horizontally.
		/// 
		/// Set to None to automatically calculate the maximum scroll position based on the size of the contents.
		maximum_horizontal: Option<f32>,
	},
}

#[inline(always)]
fn get_default_scroll_animaion() -> Animatedf32 {
	let mut current_animation = Animation::default();
	current_animation.push(AnimationNode {
		time: DEFAULT_ANIMATION_DURATION / 2.0,
		value: 1.0,
		interpolation: Linker::Bezier(Vec2::new(0.0, 0.7), Vec2::new(0.7, 1.0)),
	}); 
	Animatedf32::new(current_animation, 0.0)
}

impl Scroll {
	/// create an empty Scroll.
	pub fn empty() -> Self {
		Self::Off
	}

	/// create a vertical Scroll.
	pub fn vertical() -> Self {
		Self::Vertical {
			current: get_default_scroll_animaion(),
			maximum: None,
		}
	}

	/// create a horizontal Scroll.
	pub fn horizontal() -> Self {
		Self::Horizontal {
			current: get_default_scroll_animaion(),
			maximum: None,
		}
	}

	/// create a both Scroll.
	pub fn both() -> Self {
		Self::Both {
			current_vertical: get_default_scroll_animaion(),
			current_horizontal:get_default_scroll_animaion(),
			maximum_vertical: None,
			maximum_horizontal: None,
		}
	}

	/// set the maximum scroll position.
	pub fn max(self, maximum: f32) -> Self {
		match self {
			Self::Off => self,
			Self::Vertical { current, .. } => Self::Vertical { current, maximum: Some(maximum) },
			Self::Horizontal { current, .. } => Self::Horizontal { current, maximum: Some(maximum) },
			Self::Both { current_vertical, current_horizontal, .. } => Self::Both { current_vertical, current_horizontal, maximum_vertical: Some(maximum), maximum_horizontal: Some(maximum) },
		}
	}
}

/// The layout strategy to use for the card.
/// 
/// Describes how to arrange the contents of the card.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct LayoutStrategy {
	/// The direction of the card contents.
	pub direction: Direction,
	/// How to put the contents of the card.
	pub typesetting: Typesetting,
	/// The alignment of the contents.
	/// 
	/// In grid typesetting, the first element is for the horizontal alignment, 
	/// the second element is for the vertical alignment.
	/// In horizontal typesetting, the first element is for the vertical alignment globally, 
	/// the second element is for the horizontal alignment for each row.
	/// In vertical typesetting, the first element is for the horizontal alignment for each column, 
	/// the second element is for the vertical alignment globally.
	pub alignment: [Alignment; 2],
	/// The padding between the contents.
	pub padding: Vec2,
}

/// The alignment of the contents.
#[derive(Clone, Debug, PartialEq, Eq, Default, Copy)]
pub enum Alignment {
	/// Align the contents to the left or top.
	#[default] Positive,
	/// Align the contents to the center.
	Center,
	/// Align the contents to the right or bottom.
	Negative,
}

/// The direction of the card contents.
#[derive(Clone, Debug, PartialEq, Eq, Default, Copy)]
pub enum Direction {
	/// From left to right or top to bottom.
	#[default] Positive, 
	/// From right to left or bottom to top.
	Negative,
	/// From left to right or top to bottom but with the contents centered.
	CenterPositive,
	/// From right to left or bottom to top but with the contents centered.
	CenterNegative,
}

/// How to put the contents of the card.
#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub enum Typesetting {
	/// The contents are arranged in a single row.
	Horizontal,
	/// The contents are arranged in a single column.
	#[default] Vertical,
	/// The contents are arranged in a grid.
	Grid {
		/// The number of rows in the grid.
		rows: usize, 
		/// The number of columns in the grid.
		columns: usize,
		/// Whether the content of the grid is horizontal or vertical placced.
		is_vertical: bool,
	},
}

impl<S: Signal> Widget for Card<S> {
	type Signal = S;

	fn handle_event(&mut self, state: &mut InputState<Self::Signal>, id: LayoutId, area: Rect, _: Vec2) -> bool {
		let mut redraw = false;

		let current_size = area.size().clamp_both(Vec2::ZERO, state.window_size());
		if self.inner_size != current_size {
			self.inner_size = current_size;
			redraw = true;
		}

		let force_draggable = !matches!(self.inner.scroll, Scroll::Off);
		let res = self.signals.generate_signals(&mut self.inner, state, id, area, false, force_draggable);

		redraw | if let Some(delta) = res.drag_delta {
			let delta = - delta;
			match &mut self.inner.scroll {
				Scroll::Off => false,
				Scroll::Vertical{current, maximum} => {
					let maxium = maximum.unwrap_or(self.actual_size.y - self.inner_size.y).max(0.0);
					current.set_by(delta.y);
					current.clamp(0.0, maxium);
					current.is_animating()
				},
				Scroll::Horizontal{current, maximum} => {
					let maxium = maximum.unwrap_or(self.actual_size.x - self.inner_size.x).max(0.0);
					current.set_by(delta.x);
					current.clamp(0.0, maxium);
					current.is_animating()
				},
				Scroll::Both{
					current_vertical, 
					current_horizontal, 
					maximum_vertical, 
					maximum_horizontal
				} => {
					let maxium_vertical = maximum_vertical.unwrap_or(self.actual_size.y - self.inner_size.y).max(0.0);
					let maxium_horizontal = maximum_horizontal.unwrap_or(self.actual_size.x - self.inner_size.x).max(0.0);
					current_vertical.set_by(delta.y);
					current_horizontal.set_by(delta.x);
					current_vertical.clamp(0.0, maxium_vertical);
					current_horizontal.clamp(0.0, maxium_horizontal);
					current_horizontal.is_animating() || current_vertical.is_animating()
				},
			}
		}else {
			false
		}
	}

	fn draw(&mut self, painter: &mut Painter, size: Vec2) {
		if self.inner.dont_draw {
			return;
		}

		let desired_size = Vec2::new(
			self.inner.size.0.unwrap_or(self.inner_size.x), 
			self.inner.size.1.unwrap_or(self.inner_size.y)
		);
		let desired_rect = Rect::from_size(desired_size);
		let clip_rect = Rect::from_size(size);
		let rect_to_draw = desired_rect & clip_rect;
		let width = 1.5;

		// println!("{}, {}", self.actual_size, self.inner_size);
		
		if let Some((color, width)) = &self.inner.border {
			let lt = rect_to_draw.lt() + Vec2::x(*width);
			let card_size = rect_to_draw.size() - Vec2::x(*width);
			painter.set_fill_mode(color.clone());
			painter.draw_rect(rect_to_draw, self.inner.rounding);
			painter.set_fill_mode(self.inner.background_color.clone());
			painter.draw_rect(Rect::from_lt_size(lt, card_size), self.inner.rounding);
		}else {
			painter.set_fill_mode(self.inner.background_color.clone());
			painter.draw_rect(rect_to_draw, self.inner.rounding);
		}
		
		fn draw_scroll_bar(painter: &mut Painter, current: f32, maximum: f32, size: Vec2, is_vertical: bool) {
			// println!("{maximum}, {size}");
			if maximum <= 0.0 {
				return;
			}

			let scroll_bar_size = if is_vertical {
				Vec2::new(4.0, size.y - 8.0)
			}else {
				Vec2::new(size.x - 8.0, 4.0)
			};

			let scroll_bar_pos = if is_vertical {
				Vec2::new(size.x - 8.0, 4.0)
			}else {
				Vec2::new(4.0, size.y - 8.0)
			};

			let scroll_size = if is_vertical {
				Vec2::new(4.0, scroll_bar_size.y * size.y / (maximum + size.y))
			}else {
				Vec2::new(scroll_bar_size.x * size.x / (maximum + size.x), 4.0)
			};

			let scroll_pos = if is_vertical {
				Vec2::new(size.x - 8.0, current / maximum * (scroll_bar_size.y - scroll_size.y) + 4.0)
			}else {
				Vec2::new(current / maximum * (scroll_bar_size.x - scroll_size.x) + 4.0, size.y - 8.0)
			};

			painter.set_fill_mode(BACKGROUND_COLOR);
			painter.draw_rect(Rect::from_lt_size(scroll_bar_pos, scroll_bar_size), Vec4::same(2.0));
			painter.set_fill_mode(PRIMARY_COLOR);
			painter.draw_rect(Rect::from_lt_size(scroll_pos, scroll_size), Vec4::same(2.0));
		}

		match &self.inner.scroll {
			Scroll::Off => {},
			Scroll::Vertical{current, maximum} => {
				let maxium = maximum.unwrap_or(self.actual_size.y - self.inner_size.y).max(0.0);
				let current = current.value().clamp(0.0, maxium);
				draw_scroll_bar(painter, current, maxium, size, true);
			},
			Scroll::Horizontal{current, maximum} => {
				let maxium = maximum.unwrap_or(self.actual_size.x - self.inner_size.x).max(0.0);
				let current = current.value().clamp(0.0, maxium);
				draw_scroll_bar(painter, current, maxium, size, false);
			},
			Scroll::Both{current_vertical, current_horizontal, maximum_vertical, maximum_horizontal} => {
				let maxium_vertical = maximum_vertical.unwrap_or(self.actual_size.y - self.inner_size.y).max(0.0);
				let maxium_horizontal = maximum_horizontal.unwrap_or(self.actual_size.x - self.inner_size.x).max(0.0);
				let current_vertical = current_vertical.value().clamp(0.0, maxium_vertical);
				let current_horizontal = current_horizontal.value().clamp(0.0, maxium_horizontal);
				draw_scroll_bar(painter, current_vertical, maxium_vertical, size, true);
				draw_scroll_bar(painter, current_horizontal, maxium_horizontal, size, false);
			}
		}

		if self.inner.draw_stroke {
			painter.set_fill_mode(CARD_BORDER_COLOR);
			painter.draw_stroked_rect(rect_to_draw.shrink(Vec2::same(width)), self.inner.rounding, width);
		}

	}

	fn size(&self, _: LayoutId, _: &Painter, _: &Layout<Self::Signal>) -> Vec2 {
		Vec2::new(
			self.inner.size.0.unwrap_or(self.actual_size.x), 
			self.inner.size.1.unwrap_or(self.actual_size.y),
		)
	}

	fn handle_child_layout(&mut self, childs: indexmap::IndexMap<LayoutId, Vec2>, area: Rect, _: LayoutId) -> HashMap<LayoutId, Option<Rect>> {
		let size = Vec2::new(
			self.inner.size.0.unwrap_or(self.inner_size.x), 
			self.inner.size.1.unwrap_or(self.inner_size.y)
		);

		if childs.is_empty() {
			return HashMap::new();
		}
		
		let mut child_positions = HashMap::new();
		match &self.inner.layout_strategy.typesetting {
			Typesetting::Horizontal => {
				let padding = self.inner.layout_strategy.padding;
				let mut maxium_height: f32 = padding.y;
				let mut total_width: f32 = padding.x;
				for (_, child_size) in childs.iter() {
					maxium_height = maxium_height.max(child_size.y);
					total_width += child_size.x + padding.y;
				}

				let alignment = self.inner.layout_strategy.alignment[1];
				let dir = self.inner.layout_strategy.direction;
				let next_x = match dir {
					Direction::Positive => padding.x,
					Direction::Negative => size.x - padding.x,
					Direction::CenterPositive => (size.x - total_width) / 2.0,
					Direction::CenterNegative => (size.x + total_width) / 2.0,
				};
				let mut next = match self.inner.layout_strategy.alignment[0] {
					Alignment::Positive => Vec2::x(next_x),
					Alignment::Center => Vec2::new(next_x, (size.y - maxium_height) / 2.0),
					Alignment::Negative => Vec2::new(next_x, size.y - maxium_height - padding.y),
				} + Vec2::x(padding.x);

				for (id, child_size) in childs {
					if child_size.x < 0.0 || child_size.y < 0.0 {
						continue;
					}

					if let Some(fixed_position) = self.inner.fixed_children.get(&id) {
						child_positions.insert(id, Rect::from_lt_size(*fixed_position, child_size));
						continue;
					}
					
					let mut child_position = next;
					match alignment {
						Alignment::Positive => {}
						Alignment::Center => {
							child_position.y += (maxium_height - child_size.y) / 2.0;
						}
						Alignment::Negative => {
							child_position.y += maxium_height - child_size.y;
						}
					}

					let rect = Rect::from_lt_size(child_position - self.scroll_pos(), child_size);

					next.x += match dir {
						Direction::Positive | Direction::CenterPositive => child_size.x + padding.x,
						Direction::Negative | Direction::CenterNegative => - (child_size.x + padding.x),
					};

					if (rect.move_by(area.lt()) & area).is_empty() {
						continue;
					}

					child_positions.insert(id, rect);
				}

				self.actual_size = Vec2::new(next.x - self.inner.layout_strategy.padding.x, maxium_height);
			},
			Typesetting::Vertical => {
				let padding = self.inner.layout_strategy.padding;
				let mut maxium_width: f32 = padding.x;
				let mut total_height: f32 = padding.y;
				for (_, child_size) in childs.iter() {
					// if child_size.has_inf() {
					// 	println!("{:?}", id);
					// }
					maxium_width = maxium_width.max(child_size.x);
					total_height += child_size.y + padding.y;
				}
				// println!("{}", maxium_width);

				let alignment = self.inner.layout_strategy.alignment[0];
				let dir = self.inner.layout_strategy.direction;
				let next_y = match dir {
					Direction::Positive => padding.y,
					Direction::Negative => size.y - padding.y,
					Direction::CenterPositive => (size.y - total_height) / 2.0,
					Direction::CenterNegative => (size.y + total_height) / 2.0,
				};
				let mut next = match self.inner.layout_strategy.alignment[1] {
					Alignment::Positive => Vec2::y(next_y),
					Alignment::Center => Vec2::new((size.x - maxium_width) / 2.0, next_y),
					Alignment::Negative => Vec2::new(size.x - maxium_width - padding.y, next_y),
				} + Vec2::x(padding.x);
				
				for (id, child_size) in childs {
					if child_size.x < 0.0 || child_size.y < 0.0 {
						continue;
					}

					if let Some(fixed_position) = self.inner.fixed_children.get(&id) {
						child_positions.insert(id, Rect::from_lt_size(*fixed_position, child_size));
						continue;
					}
					
					let mut child_position = next;
					match alignment {
						Alignment::Positive => {}
						Alignment::Center => {
							child_position.x += (maxium_width - child_size.x) / 2.0;
						}
						Alignment::Negative => {
							child_position.x += maxium_width - child_size.x;
						}
					}
					
					let rect = Rect::from_lt_size(child_position - self.scroll_pos(), child_size);

					next.y += match dir {
						Direction::Positive | Direction::CenterPositive => child_size.y + padding.y,
						Direction::Negative | Direction::CenterNegative => - (child_size.y + padding.y),
					};
					
					if (rect.move_by(area.lt()) & area).is_empty() {
						continue;
					}

					child_positions.insert(id, rect);
				}
				self.actual_size = Vec2::new(maxium_width, next.y - self.inner.layout_strategy.padding.y);
			},
			Typesetting::Grid { rows, columns, is_vertical } => {
				let block_size = size / Vec2::new(*columns as f32, *rows as f32);
				for id in 0..*rows * *columns {
					let (row, column) = if *is_vertical {
						(id / *columns, id % *columns)
					}else {
						(id % *rows, id / *rows)
					};

					let (child_id, child_size) = if let Some(inner) = childs.get_index(id) {
						(*inner.0, *inner.1)
					}else {
						break;
					};

					if child_size.x <= 0.0 || child_size.y <= 0.0 {
						continue;
					}

					if let Some(fixed_position) = self.inner.fixed_children.get(&child_id) {
						child_positions.insert(child_id, Rect::from_lt_size(*fixed_position, child_size));
						continue;
					}

					let mut child_position = block_size * Vec2::new(column as f32, row as f32);
					match self.inner.layout_strategy.alignment[0] {
						Alignment::Positive => {}
						Alignment::Center => {
							child_position.x += (block_size.x - child_size.x) / 2.0;
						}
						Alignment::Negative => {
							child_position.x += block_size.x - child_size.x;
						}
					}

					match self.inner.layout_strategy.alignment[1] {
						Alignment::Positive => {}
						Alignment::Center => {
							child_position.y += (block_size.y - child_size.y) / 2.0;
						}
						Alignment::Negative => {
							child_position.y += block_size.y - child_size.y;
						}
					}

					child_positions.insert(child_id, Rect::from_lt_size(child_position, child_size) & Rect::from_lt_size(child_position, block_size));
				}

				self.actual_size = size;
			},
		}

		child_positions.into_iter().map(|(id, rect)| (id, Some(rect))).collect()
	}

	fn inner_padding(&self) -> Vec2 {
		self.inner.layout_strategy.padding
	}
}